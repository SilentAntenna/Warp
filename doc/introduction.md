介绍
======

为什么要有Warp这个语言
------

我们首先来个下马威。看下面这个东西：

`λf.(λx.f (x x)) (λx.f (x x))`

Y组合子是吧。那么好，告诉我上面这个表达式里有几个应用(application)，这个式子能不能进行β-归约。

一眼看不出来吧。我自己也看不出来啊！这种蛋疼的表达方法就是作者每次想起Y组合子又忘了推导过程的时候不得不将这个式子看上十分钟的原因。这帮搞lambda演算的人想出来的，**用空格来表示应用**的办法，简直是程序可读性领域中的神作。众所周知，英文字体大多数都是非等宽字体。等这些lambda表达式用latex打出来放到论文里，空格的宽度往往只有字母的四分之一。你根本搞不清他到底写的是Y f g还是Yfg还是Yf g。这种表达方法简直就是凭空给PLT书籍增加理解难度。此外，**lambda表达式函数边界不清晰**这个问题更是烦人，鉴于lambda表达式只有一种括号（就是圆括号），教材的作者又在自己用着舒服的前提下随便加减括号或者定义新的算符，而且经常懒得说明这些新算符到底是左结合优先，右结合优先，还是使用什么其他的鬼规则，结果读完书就感觉自己大脑里跑了一遍语法分析器一样累。

好，那我们换一种表达方法：

`{f: {x: f->(x->x) } -> {x: f->(x->x) } }`

数箭头，5个应用。最外层被花括号括起来，说明整个表达式是个函数，不能进行β-归约。

这就是作者搞Warp语言的一个原因 - 作者希望把自己看的PLT书用这种新语言重新写一遍，方便日后参考。不过这只是原因之一。实用方面的考虑也有。

在2017年8月某个无聊的下午，本文的作者通过将程序参数改来改去，妄图找出一组合适的参数使得作者的渣方法能够超越对照方法，然而由于参数全部是手工填写，没过多久就连作者都不记得哪几组参数试过，哪几组参数没试过了。于是看在不耐烦的导师的面子上，作者自己写了一个生成正交实验用配置文件的小工具。

这个工具需要一点点的宏功能。于是作者本着怎么方便怎么写的原则，搞了一个类似于lisp的宏语法（lisp语法有一个好，就是解释器写起来方便，如果要处理的程序结构足够简单的话，一两天就可以写出勉强能用的解释器）。然而到了这一步，作者发现了一个很严重的问题：

我们假设有一个参数组A，A下面有三个小参数A.a，A.b，A.c。我们有时要调用A，有时要调用A.a，A.b，A.c。然而问题来了。众所周知，lisp只有列表，没有**dot**这种神奇的运算符。要在基础的lisp语法上搞出类似的东西，只能用闭包（`define-struct`搞出来的东西本质上也是闭包，谢谢）。且不说空手写闭包这种事情很烦代码看上去很不好懂，关键是 - 我一天写出来的解释器根本没有词法作用域这种东西，完全写不出闭包啊！

所以作者决定既然一两天内解释器写不完，那就写个大的，仔细设计一下语言特性，一次性把所有问题都解决掉。

这就是现在这个语言的来源。鉴于作者在研一（不是大一，我之前发错了……）时期已经写过一个非常渣的语言的解释器，对于自己会遇到的坑多少有些概念。现在搞出来的这个语言有下面这些特性：

* 纯函数式。因为好写。命令式语言一千行代码连语法分析器都搞不出来。我见过有某些人说组合子逻辑才是真正的**纯**函数式（因为你根本写不出不是函数的东西），不过有趣的是，这件事在我的语言里也做到了，所有的东西都是函数，甚至常量，符号和类型也是。
* 弱类型。脚本语言要什么类型推断。
* 及早求值。也是因为好写。
* 没有未定义行为。只要输入的是语法正确的表达式，就不会有未定义行为。编译通过 = 运行通过。当然，最终的返回值可能是一个异常，程序也可能陷入死循环（毕竟停机不可判定）。

当然，也有很多想实现但没实现的特性：

* I/O。怎么搞比较好我还没想通。
* call/cc。这东西看似很好明白，实际上越想越觉得这是个坑，所以还是不要轻易踩下去为好。

写了这么多，好像Warp的语法一个字也没有提，这就等下一篇吧……